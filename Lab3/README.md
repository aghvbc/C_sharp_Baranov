# README.md для Лабораторной работы №3
# Лабораторная работа 3  
**Тема:** реализация коллекций и интерфейсов в C#

## 1. Краткое описание

В лабораторной реализованы:

1. Класс `SimpleList<T>` (папка `src`) — динамический список на основе массива, реализующий интерфейсы `IList<T>`, `ICollection<T>`, `IEnumerable<T>`.
2. Класс `SimpleDictionary<TKey, TValue>` (папка `src`) — хеш-таблица с разрешением коллизий методом цепочек, реализующая интерфейсы `IDictionary<TKey, TValue>`, `IReadOnlyDictionary<TKey, TValue>`.
3. Класс `DoublyLinkedList<T>` (папка `src`) — двунаправленный связный список, реализующий интерфейсы `IList<T>`, `IReadOnlyList<T>`.
4. Консольное приложение (`Program.cs`) для демонстрации работы всех коллекций.
5. Отдельный тестовый проект `Lab3.Tests` (`tests/Lab3.Tests`) с юнит-тестами для всех коллекций.

### Используемые технологии

| Технология   | Версия / Фреймворк |
|--------------|--------------------|
| C#           | 12+                |
| .NET SDK     | 9.0                |
| xUnit        | 2.9.0              |

IDE: Visual Studio Code

### Используемые пространства имён

- `System`
- `System.Collections`
- `System.Collections.Generic`

---

## 2. Основные интерфейсы

В работе изучены и реализованы следующие интерфейсы .NET:

| Интерфейс | Описание |
|-----------|----------|
| `IEnumerable<T>` | Поддержка перебора элементов (foreach) |
| `ICollection<T>` | Базовые операции: добавление, удаление, подсчёт элементов |
| `IList<T>` | Индексированный доступ, вставка, удаление по индексу |
| `IDictionary<TKey, TValue>` | Словарь, работа с ключами и значениями |
| `IReadOnlyList<T>` | Список только для чтения |
| `IReadOnlyDictionary<TKey, TValue>` | Словарь только для чтения |

---

## 3. Класс SimpleList<T>

Динамический список на основе массива с автоматическим расширением ёмкости.

### Реализованные интерфейсы

- `IList<T>`
- `ICollection<T>`
- `IEnumerable<T>`

### Основные методы и свойства

| Член | Описание | Сложность |
|------|----------|-----------|
| `Count` | Количество элементов | O(1) |
| `this[index]` | Доступ по индексу (get/set) | O(1) |
| `Add(item)` | Добавление в конец | O(1)* |
| `Insert(index, item)` | Вставка по индексу | O(n) |
| `Remove(item)` | Удаление первого вхождения | O(n) |
| `RemoveAt(index)` | Удаление по индексу | O(n) |
| `IndexOf(item)` | Поиск индекса элемента | O(n) |
| `Contains(item)` | Проверка наличия | O(n) |
| `Clear()` | Очистка списка | O(n) |
| `CopyTo(array, index)` | Копирование в массив | O(n) |
| `GetEnumerator()` | Перебор элементов | O(1) |

*амортизированная сложность (при расширении массива — O(n))

### Особенности реализации

- Начальная ёмкость массива: 4 элемента
- При переполнении ёмкость удваивается
- Используется `EqualityComparer<T>.Default` для сравнения элементов
- Реализован через `yield return` для поддержки `foreach`

---

## 4. Класс SimpleDictionary<TKey, TValue>

Хеш-таблица с разрешением коллизий методом цепочек (chaining).

### Реализованные интерфейсы

- `IDictionary<TKey, TValue>`
- `IReadOnlyDictionary<TKey, TValue>`
- `IEnumerable<KeyValuePair<TKey, TValue>>`

### Основные методы и свойства

| Член | Описание | Средняя сложность |
|------|----------|-------------------|
| `Count` | Количество пар | O(1) |
| `this[key]` | Доступ по ключу (get/set) | O(1) |
| `Add(key, value)` | Добавление пары | O(1) |
| `Remove(key)` | Удаление по ключу | O(1) |
| `ContainsKey(key)` | Проверка наличия ключа | O(1) |
| `TryGetValue(key, out value)` | Безопасное получение | O(1) |
| `Keys` | Коллекция ключей | O(n) |
| `Values` | Коллекция значений | O(n) |
| `Clear()` | Очистка словаря | O(n) |

### Особенности реализации

- Начальная ёмкость: 16 корзин (buckets)
- Коэффициент загрузки (load factor): 0.75
- Автоматическое расширение при превышении load factor
- Каждая корзина — односвязный список узлов `Entry`
- Индекс корзины вычисляется как `Math.Abs(key.GetHashCode()) % buckets.Length`

### Структура хеш-таблицы

```
Buckets[]:
┌───┐
│ 0 │ → null
├───┤
│ 1 │ → [Key1,Val1] → [Key5,Val5] → null  (коллизия)
├───┤
│ 2 │ → [Key2,Val2] → null
├───┤
│ 3 │ → null
└───┘
```

---

## 5. Класс DoublyLinkedList<T>

Двунаправленный (двусвязный) связный список.

### Реализованные интерфейсы

- `IList<T>`
- `IReadOnlyList<T>`
- `IEnumerable<T>`

### Основные методы и свойства

| Член | Описание | Сложность |
|------|----------|-----------|
| `Count` | Количество элементов | O(1) |
| `this[index]` | Доступ по индексу | O(n)* |
| `Add(item)` | Добавление в конец | O(1) |
| `AddFirst(item)` | Добавление в начало | O(1) |
| `AddLast(item)` | Добавление в конец | O(1) |
| `Insert(index, item)` | Вставка по индексу | O(n) |
| `Remove(item)` | Удаление элемента | O(n) |
| `RemoveAt(index)` | Удаление по индексу | O(n) |
| `IndexOf(item)` | Поиск индекса | O(n) |
| `Contains(item)` | Проверка наличия | O(n) |
| `Clear()` | Очистка списка | O(1) |

*Оптимизация: доступ с ближайшего конца (head или tail)

### Структура узла

```csharp
private class Node
{
    public T Value;
    public Node? Previous;
    public Node? Next;
}
```

### Визуализация структуры

```
null ⟷ [START] ⟷ [A] ⟷ [B] ⟷ [C] ⟷ [END] ⟷ null
        ↑ head                         ↑ tail
```

---

## 6. Сравнение коллекций

| Операция | SimpleList | SimpleDictionary | DoublyLinkedList |
|----------|------------|------------------|------------------|
| Добавление в конец | O(1)* | — | O(1) |
| Добавление в начало | O(n) | — | O(1) |
| Вставка в середину | O(n) | — | O(n) |
| Удаление из середины | O(n) | O(1) | O(n) |
| Поиск по индексу | O(1) | — | O(n) |
| Поиск по значению/ключу | O(n) | O(1) | O(n) |
| Память | Компактная | Больше (цепочки) | Больше (указатели) |

---

## 7. Тестирование

Тесты реализованы в проекте `Lab3.Tests` (папка `tests/Lab3.Tests`) на базе xUnit.

### SimpleListTests

- Добавление одного и нескольких элементов
- Автоматическое расширение при переполнении
- Поиск элементов (`IndexOf`, `Contains`)
- Удаление элементов (`Remove`, `RemoveAt`)
- Вставка по индексу (`Insert`)
- Очистка списка (`Clear`)
- Перебор через `foreach`
- Исключения при некорректных индексах
- Копирование в массив (`CopyTo`)

### SimpleDictionaryTests

- Добавление и получение пар ключ-значение
- Исключение при дублировании ключа
- Обновление значения через индексатор
- Удаление по ключу
- Методы `ContainsKey`, `TryGetValue`
- Свойства `Keys` и `Values`
- Перебор через `foreach`
- Автоматическое расширение при большом количестве элементов

### DoublyLinkedListTests

- Добавление в начало и конец
- Вставка в середину
- Удаление первого, последнего и среднего элементов
- Доступ по индексу (оптимизация с обоих концов)
- Очистка списка
- Перебор через `foreach`

---

## 8. Структура проекта

```
Lab3/
├── Lab3.sln                 # Solution файл
├── Lab3.csproj              # Основной проект
├── Program.cs               # Демонстрационное приложение
├── README.md                # Документация
├── .gitignore               # Исключения для Git
│
├── src/                     # Исходный код коллекций
│   ├── SimpleList.cs
│   ├── SimpleDictionary.cs
│   └── DoublyLinkedList.cs
│
└── tests/
    └── Lab3.Tests/          # Тестовый проект
        ├── Lab3.Tests.csproj
        ├── SimpleListTests.cs
        ├── SimpleDictionaryTests.cs
        └── DoublyLinkedListTests.cs
```

---

## 9. Инструкция по запуску

### Требования

- .NET SDK 9.0 или выше

### Проверка версии .NET

```bash
dotnet --version
```

### Сборка проекта

```bash
dotnet build
```

### Запуск демонстрации

```bash
dotnet run
```

### Запуск тестов

```bash
dotnet test
```

### Запуск тестов с подробным выводом

```bash
dotnet test --verbosity normal
```

---

## 10. Вопросы для защиты

### IEnumerable и foreach

- `IEnumerable<T>` предоставляет метод `GetEnumerator()`, возвращающий `IEnumerator<T>`
- `foreach` вызывает `GetEnumerator()`, затем в цикле `MoveNext()` и `Current`
- Можно реализовать `foreach` без `IEnumerable` (duck typing), но это не рекомендуется

### ICollection vs IList

- `ICollection<T>` — базовые операции без индексов
- `IList<T>` добавляет: `this[index]`, `IndexOf`, `Insert`, `RemoveAt`
- Используйте `ICollection` для HashSet, Queue; `IList` для упорядоченных коллекций

### Хеш-таблица

- Ключ преобразуется в индекс через `GetHashCode()` и операцию модуля
- Коллизии разрешаются цепочками (связные списки в корзинах)
- Средняя сложность операций O(1), худшая O(n)

---

