# Лабораторная работа 2
## **Тема:** Работа с коллекциями — анализ и сравнение производительности

## 1. Краткое описание

В лабораторной реализованы:

1. Класс `CollectionBenchmark` (папка `Lab2/Services`) — замеры производительности операций над коллекциями.
2. Класс `BenchmarkResult` (папка `Lab2/Services`) — модель для хранения результатов измерений.
3. Консольное приложение `Lab2` (`Lab2/Program.cs`) — запуск бенчмарков и вывод результатов.
4. Тестовый проект `Lab2.Tests` (`tests/Lab2.Tests`) — юнит-тесты для проверки корректности операций над коллекциями.

### Используемые технологии

| Технология | Версия |
|------------|--------|
| C# | 12 |
| .NET SDK | 9.0 |
| xUnit | 2.5+ |

IDE: Visual Studio Code

### Используемые пространства имён

- `System`
- `System.Collections.Generic`
- `System.Collections.Immutable`
- `System.Diagnostics`
- `System.Linq`

---

## 2. Подход к реализации замеров

### Инструмент измерения

Для замеров используется класс `System.Diagnostics.Stopwatch` — высокоточный таймер с точностью до тиков процессора.

```csharp
var sw = Stopwatch.StartNew();  // Запуск таймера
// ... измеряемый код ...
sw.Stop();                       // Остановка
double ms = sw.Elapsed.TotalMilliseconds;  // Результат
```

### Параметры тестирования
|Параметр |	Значение |	Обоснование|
|----------|----------|-------------|
|Количество элементов |	100 000	 | Достаточно для выявления разницы O(1) vs O(n)|
|Количество итераций |	5 |	Усреднение для минимизации случайных факторов|
|Количество поисков |	1000 |	Один поиск слишком быстрый для точного замера|


### Структура бенчмарка

#### Каждый метод измерения следует единому шаблону:

``` csharp

public BenchmarkResult ИмяОперации()
{
    var times = new List<double>();

    for (int i = 0; i < _iterations; i++)
    {
        // Подготовка данных ВНЕ замера
        var collection = new List<int>();
        
        var sw = Stopwatch.StartNew();
        
        // Тестируемая операция
        for (int j = 0; j < _elementCount; j++)
            collection.Add(j);
        
        sw.Stop();
        times.Add(sw.Elapsed.TotalMilliseconds);
    }

    return new BenchmarkResult
    {
        CollectionType = "List<T>",
        Operation = "Add End",
        AverageTimeMs = times.Average()
    };
}

```

## 3. Результаты замеров

Параметры: 100 000 элементов, 5 итераций, среда .NET 9.0

### Полная таблица результатов

| Коллекция | Операция | Время (мс) |
|-----------|----------|------------|
| List\<T\> | Add End | 0,4413 |
| List\<T\> | Add Beginning | 277,5437 |
| List\<T\> | Add Middle | 136,5966 |
| List\<T\> | Remove End | 0,3071 |
| List\<T\> | Remove Beginning | 277,7926 |
| List\<T\> | Search  | 9,1322 |
| List\<T\> | Get By Index | 0,1230 |
| LinkedList\<T\> | Add End | 4,0364 |
| LinkedList\<T\> | Add Beginning | 3,6472 |
| LinkedList\<T\> | Remove End | 0,9314 |
| LinkedList\<T\> | Remove Beginning | 1,1089 |
| LinkedList\<T\> | Search  | 140,8440 |
| Queue\<T\> | Enqueue | 0,8204 |
| Queue\<T\> | Dequeue | 0,4138 |
| Queue\<T\> | Search (×1000) | 9,1319 |
| Stack\<T\> | Push | 0,4958 |
| Stack\<T\> | Pop | 0,2876 |
| Stack\<T\> | Search  | 9,3356 |
| ImmutableList\<T\> | Add End | 55,5422 |
| ImmutableList\<T\> | Add Beginning | 48,6886 |
| ImmutableList\<T\> | Search  | 52,1761 |
| ImmutableList\<T\> | Get By Index | 7,3579 |

## 4. Анализ коллекций

### List<T>

#### Структура: Динамический массив

Преимущества:

    Add End: 0,44 мс — O(1) амортизированное
    Get By Index: 0,12 мс — O(1) прямой доступ
    Search: 9,13 мс — хорошая кэш-локальность

Недостатки:

    Add Beginning: 277,54 мс — O(n) сдвиг всех элементов
    Remove Beginning: 277,79 мс — O(n) сдвиг всех элементов

### LinkedList<T>

#### Структура: Двусвязный список

Преимущества:

    Add Beginning: 3,65 мс — O(1), в 76 раз быстрее List
    Remove Beginning: 1,11 мс — O(1)

Недостатки:

    Search: 140,84 мс — O(n), в 15 раз медленнее List (cache miss)
    Нет доступа по индексу

### Queue<T>

#### Структура: Кольцевой буфер

Преимущества:

    Dequeue: 0,41 мс — O(1), в 671 раз быстрее List.RemoveAt(0)
    Enqueue: 0,82 мс — O(1)

Недостатки:

    Только FIFO-операции
    Нет доступа по индексу

### Stack<T>

#### Структура: Динамический массив

Преимущества:

    Pop: 0,29 мс — O(1), самый быстрый для удаления с конца
    Push: 0,50 мс — O(1)

Недостатки:

    Только LIFO-операции
    Нет доступа по индексу

### ImmutableList<T>

#### Структура: Персистентное дерево

Преимущества:

    Потокобезопасность без блокировок
    Сохранение всех версий

Недостатки:

    Add End: 55,54 мс — в 126 раз медленнее List
    Get By Index: 7,36 мс — в 60 раз медленнее List



## 5. Рекомендации по применению коллекций

На основе структуры данных и фактических замеров:
- List\<T\>
    - Использовать:
        - при необходимости быстрого произвольного доступа по индексу
        - когда основная нагрузка — чтение, перебор, поиск
        - когда вставки и удаления в основном происходят в конце
    - Не использовать:
        - для частых вставок/удалений в начале и середине больших списков


- LinkedList<T>
    - Использовать:
        - при частых вставках и удалениях в начале/конце;
        - когда нужно удалять элементы, зная ссылку на узел (LinkedListNode<T>).
    - Не использовать:
        - когда нужен быстрый поиск по значению;
        - когда требуется доступ по индексу.

- Queue<T>
    - Использовать:
        - для очередей задач, сообщений, запросов (FIFO);
        - когда нужны быстрые Enqueue и Dequeue без сдвигов.
    - Не использовать:
        - если нужен произвольный доступ по индексу или вставки в середину.

- Stack<T>
    - Использовать:
        - для реализаций стеков (LIFO): undo/redo, парсинг, обход графов/деревьев (DFS).
    - Не использовать:
        - для FIFO‑очередей или произвольного доступа.

- ImmutableList<T>
    - Использовать:
        - когда важнее неизменяемость и потокобезопасность, чем максимальная скорость;
        - для хранения нескольких версий коллекций (история изменений, функциональный стиль).
    - Не использовать:
        - когда требуется высокая производительность модификаций больших коллекций;
        - в критических по скорости участках кода без необходимости в неизменяемости.


## 6. Инструкция по запуску

- cd Lab2
- dotnet run
##### для тестов:
- cd Lab2
- dotnet test
